global:
  imageRegistry: ""
  ## E.g.
  ## imagePullSecrets:
  ##   - myRegistryKeySecretName
  ##
  imagePullSecrets: []
  storageClass: "gfs1-ssd"
  elasticsearch:
    service:
      name: dev-cpoe-elasticsearch
      ports:
        restAPI: 9200
  kibanaEnabled: true 

#clusterDomain: dev-cpoe
namespaceOverride: "dev-cpoe"


clusterName: elastic
containerPorts:
  restAPI: 9200
  transport: 9300
#config: {}
## @param extraConfig Append extra configuration to the elasticsearch node configuration
## Use this instead of `config` to add more configuration
## See below example:
## extraConfig:
##   node:
##     store:
##       allow_mmap: false
## ref: https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html
##
extraConfig: {}
extraHosts: []
image:
  registry: docker.io
  repository: bitnami/elasticsearch
  tag: 7.17.7-debian-11-r2
  digest: ""
  pullPolicy: IfNotPresent
  pullSecrets: []
  ## Enable debug mode
  ##
  debug: false

security:
  ## @param security.enabled Enable X-Pack Security settings
  ##
  enabled: false 
  ## @param security.elasticPassword Password for 'elastic' user
  ##
  elasticPassword: ""
  ## @param security.existingSecret Name of the existing secret containing the Elasticsearch password and
  ##
  existingSecret: ""
  ## FIPS mode
  ## @param security.fipsMode Configure elasticsearch with FIPS 140 compliant mode
  ## Ref: https://www.elastic.co/guide/en/elasticsearch/reference/current/fips-140-compliance.html
  ##
  fipsMode: false 
  ## TLS configuration
  ##
  tls:
    ## @param security.tls.restEncryption Enable SSL/TLS encryption for Elasticsearch REST API.
    ##
    restEncryption: false
    ## @param security.tls.autoGenerated Create self-signed TLS certificates.
    ## NOTE: If autoGenerated certs are enabled and a new node type is enabled using helm upgrade, make sure you remove previously existing Elasticsearch TLS secrets.
    ## Otherwise, the new node certs won't match the existing certs.
    ##
    autoGenerated: false
    ## @param security.tls.verificationMode Verification mode for SSL communications.
    ## Supported values: full, certificate, none.
    ## Ref: https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html
    ##
    verificationMode: "none"
    ## @param security.tls.master.existingSecret Existing secret containing the certificates for the master nodes
    ## @param security.tls.data.existingSecret Existing secret containing the certificates for the data nodes
    ## @param security.tls.ingest.existingSecret Existing secret containing the certificates for the ingest nodes
    ## @param security.tls.coordinating.existingSecret Existing secret containing the certificates for the coordinating nodes
    ##
    master:
      existingSecret: ""
    data:
      existingSecret: ""
    ingest:
      existingSecret: ""
    coordinating:
      existingSecret: ""
    ## @param security.tls.keystoreFilename Name of the keystore file
    ##
    keystoreFilename: elasticsearch.keystore.jks
    ## @param security.tls.truststoreFilename Name of the truststore
    ##
    truststoreFilename: elasticsearch.truststore.jks
    ## @param security.tls.usePemCerts Use this variable if your secrets contain PEM certificates instead of JKS/PKCS12
    ## Ignored when using autoGenerated certs.
    ##
    usePemCerts: false 
    ## @param security.tls.passwordsSecret Existing secret containing the Keystore and Truststore passwords, or key password if PEM certs are used
    ##
    passwordsSecret: ""
    ## @param security.tls.keystorePassword Password to access the JKS/PKCS12 keystore or PEM key when they are password-protected.
    ## Ignored if security.tls.passwordsSecret is provided.
    ##
    keystorePassword: ""
    ## @param security.tls.truststorePassword Password to access the JKS/PKCS12 truststore when they are password-protected.
    ## Ignored if security.tls.passwordsSecret is provided.
    ##
    truststorePassword: ""
    ## @param security.tls.keyPassword Password to access the PEM key when they are password-protected.
    ## Ignored if security.tls.passwordsSecret is provided.
    ##
    keyPassword: ""
    ## @param security.tls.secretKeystoreKey Name of the secret key containing the Keystore password
    ##
    secretKeystoreKey: ""
    ## @param security.tls.secretTruststoreKey Name of the secret key containing the Truststore password
    ##
    secretTruststoreKey: ""
    ## @param security.tls.secretKey Name of the secret key containing the PEM key password
    ##
    secretKey: ""

## @section Traffic Exposure Parameters
##

## Elasticsearch service parameters
##
service:
  ## @param service.type Elasticsearch service type
  ##
  type: ClusterIP
  ## @param service.ports.restAPI Elasticsearch service REST API port
  ## @param service.ports.transport Elasticsearch service transport port
  ##
  ports:
    restAPI: 9200
    transport: 9300
  ## Node ports to expose
  ## @param service.nodePorts.restAPI Node port for REST API
  ## @param service.nodePorts.transport Node port for REST API
  ## NOTE: choose port between <30000-32767>
  ##
  nodePorts:
    restAPI: ""
    transport: ""
  ## @param service.clusterIP Elasticsearch service Cluster IP
  ## e.g.:
  ## clusterIP: None
  ##
  clusterIP: ""
  ## @param service.loadBalancerIP Elasticsearch service Load Balancer IP
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer
  ##
  loadBalancerIP: ""
  ## @param service.loadBalancerSourceRanges Elasticsearch service Load Balancer sources
  ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
  ## e.g:
  ## loadBalancerSourceRanges:
  ##   - 10.10.10.0/24
  ##
  loadBalancerSourceRanges: []
  ## @param service.externalTrafficPolicy Elasticsearch service external traffic policy
  ## ref http://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
  ##
  externalTrafficPolicy: Cluster
  ## @param service.annotations Additional custom annotations for Elasticsearch service
  ##
  annotations: {}
  ## @param service.extraPorts Extra ports to expose in Elasticsearch service (normally used with the `sidecars` value)
  ##
  extraPorts: []
  ## @param service.sessionAffinity Session Affinity for Kubernetes service, can be "None" or "ClientIP"
  ## If "ClientIP", consecutive client requests will be directed to the same Pod
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  ##
  sessionAffinity: None
  ## @param service.sessionAffinityConfig Additional settings for the sessionAffinity
  ## sessionAffinityConfig:
  ##   clientIP:
  ##     timeoutSeconds: 300
  ##
  sessionAffinityConfig: {}

## Elasticsearch ingress parameters
## ref: http://kubernetes.io/docs/user-guide/ingress/
##
ingress:
  ## @param ingress.enabled Enable ingress record generation for Elasticsearch
  ##
  enabled: false
  ## @param ingress.pathType Ingress path type
  ##
  pathType: ImplementationSpecific
  ## @param ingress.apiVersion Force Ingress API version (automatically detected if not set)
  ##
  apiVersion: ""
  ## @param ingress.hostname Default host for the ingress record
  ##
#  hostname: elasticsearch.local
  ## @param ingress.path Default path for the ingress record
  ## NOTE: You may need to set this to '/*' in order to use this with ALB ingress controllers
  ##
  path: /
  ## @param ingress.annotations Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
  ## Use this parameter to set the required annotations for cert-manager, see
  ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
  ## e.g:
  ## annotations:
  ##   kubernetes.io/ingress.class: nginx
  ##   cert-manager.io/cluster-issuer: cluster-issuer-name
  ##
  annotations: {}
  ## @param ingress.tls Enable TLS configuration for the host defined at `ingress.hostname` parameter
  ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
  ## You can:
  ##   - Use the `ingress.secrets` parameter to create this TLS secret
  ##   - Rely on cert-manager to create it by setting the corresponding annotations
  ##   - Rely on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
  ##
  tls: false
  ## @param ingress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
  ##
  selfSigned: false
  ## @param ingress.ingressClassName IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
  ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
  ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
  ##

master:
  ## @param master.masterOnly Deploy the Elasticsearch master-elegible nodes as master-only nodes. Recommended for high-demand deployments.
  ## If you are
  masterOnly: true
  ## @param master.replicaCount Number of master-elegible replicas to deploy
  ##
  replicaCount: 2
  ## @param master.nameOverride String to partially override elasticsearch.master.fullname
  ##
  nameOverride: ""
  ## @param master.fullnameOverride String to fully override elasticsearch.master.fullname
  ##
  fullnameOverride: ""
  ## @param master.servicenameOverride String to fully override elasticsearch.master.servicename
  ##
  servicenameOverride: ""
  ## @param master.annotations [object] Annotations for the master statefulset
  ##
  annotations: {}
  ## @param master.updateStrategy.type Master-elegible nodes statefulset stategy type
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy:
    type: RollingUpdate
  ## Elasticsearch resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ## @param master.resources.limits The resources limits for the master-elegible containers
  ## @param master.resources.requests [object] The requested resources for the master-elegible containers
  ##
  resources:
    limits: {}
    requests:
      cpu: 25m
      memory: 256Mi
  heapSize: 1024m
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
    runAsNonRoot: true
  podManagementPolicy: "Parallel"
  startupProbe:
    enabled: false
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  livenessProbe:
    enabled: true
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  readinessProbe:
    enabled: true
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  persistence:
    enabled: true
    storageClass: "gfs1-ssd"
    accessModes:
      - ReadWriteOnce
    size: 2Gi
  serviceAccount:
    create: false
    name: ""
    automountServiceAccountToken: true
    annotations: {}
  autoscaling:
    enabled: false
    minReplicas: 3
    maxReplicas: 11
    targetCPU: ""
    targetMemory: ""

data:
  ## @param data.replicaCount Number of data-only replicas to deploy
  ##
  replicaCount: 2
  ## @param data.nameOverride String to partially override elasticsearch.data.fullname
  ##
  updateStrategy:
    type: RollingUpdate
  ##
  resources:
    limits: {}
    requests:
      cpu: 25m
      memory: 2048Mi
  heapSize: 1024m
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
    runAsNonRoot: true
  podManagementPolicy: "Parallel"
  startupProbe:
    enabled: false
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  livenessProbe:
    enabled: true
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  readinessProbe:
    enabled: true
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  persistence:
    enabled: true
    storageClass: "gfs1-ssd"
    accessModes:
      - ReadWriteOnce
    size: 2Gi
  serviceAccount:
    create: false
    name: ""
    automountServiceAccountToken: true
    annotations: {}
  autoscaling:
    enabled: false
    minReplicas: 3
    maxReplicas: 11
    targetCPU: ""
    targetMemory: ""

coordinating:
  replicaCount: 2
  nameOverride: ""
  fullnameOverride: ""
  servicenameOverride: ""
  annotations: {}
  updateStrategy:
    type: RollingUpdate
  resources:
    limits: {}
    requests:
      cpu: 25m
      memory: 256Mi
  heapSize: 1024m
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
    runAsNonRoot: true
  podManagementPolicy: "Parallel"
  startupProbe:
    enabled: false
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  livenessProbe:
    enabled: true
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  readinessProbe:
    enabled: true
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  serviceAccount:
    create: false
    name: ""
    automountServiceAccountToken: true
    annotations: {}
  autoscaling:
    enabled: false
    minReplicas: 3
    maxReplicas: 11
    targetCPU: ""
    targetMemory: ""


ingest:
  ## @param ingest.enabled Enable ingest nodes
  ##
  enabled: false 
  ##
  prometheusRule:
    ## @param metrics.prometheusRule.enabled Creates a Prometheus Operator PrometheusRule (also requires `metrics.enabled` to be `true` and `metrics.prometheusRule.rules`)
    ##
    enabled: false
    ## @param metrics.prometheusRule.namespace Namespace for the PrometheusRule Resource (defaults to the Release Namespace)
    ##
    namespace: ""
    ## @param metrics.prometheusRule.additionalLabels Additional labels that can be used so PrometheusRule will be discovered by Prometheus
    ##
    additionalLabels: {}
    ## @param metrics.prometheusRule.rules Prometheus Rule definitions
      # - alert: es cluster error
      #   annotations:
      #     summary: "es cluster error"
      #     description: "es cluster error, cluster state {{`{{`}} $labels.color {{`}}`}}"
      #   expr: elasticsearch_cluster_health_status{color="red"} ==1 or elasticsearch_cluster_health_status{color="yellow"} ==1
      #   for: 1m
      #   labels:
      #     severity: critical
      #     group: PaaS
    ##
    rules: []

## @section Init Container Parameters

## 'volumePermissions' init container parameters
## Changes the owner and group of the persistent volume mount point to runAsUser:fsGroup values
##   based on the *podSecurityContext/*containerSecurityContext parameters
##
volumePermissions:
  ## @param volumePermissions.enabled Enable init container that changes volume permissions in the data directory (for cases where the default k8s `runAsUser` and `fsUser` values do not work)
  ##
  enabled: false
  ## @param volumePermissions.image.registry Init container volume-permissions image registry
  ## @param volumePermissions.image.repository Init container volume-permissions image name
  ## @param volumePermissions.image.tag Init container volume-permissions image tag
  ## @param volumePermissions.image.digest Init container volume-permissions image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
  ## @param volumePermissions.image.pullPolicy Init container volume-permissions image pull policy
  ## @param volumePermissions.image.pullSecrets Init container volume-permissions image pull secrets
  ##
  image:
    registry: docker.io
    repository: bitnami/bitnami-shell
    tag: 11-debian-11-r87
    digest: ""
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  ## Init container' resource requests and limits
  ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ## We usually recommend not to specify default resources and to leave this as a conscious
  ## choice for the user. This also increases chances charts run on environments with little
  ## resources, such as Minikube. If you do want to specify resources, uncomment the following
  ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  ## @param volumePermissions.resources.limits The resources limits for the container
  ## @param volumePermissions.resources.requests The requested resources for the container
  ##
  resources:
    ## Example:
    ## limits:
    ##    cpu: 100m
    ##    memory: 128Mi
    limits: {}
    ## Examples:
    ## requests:
    ##    cpu: 100m
    ##    memory: 128Mi
    requests: {}

## Kernel settings modifier image
##
sysctlImage:
  ## @param sysctlImage.enabled Enable kernel settings modifier image
  ##
  enabled: true
  ## @param sysctlImage.registry Kernel settings modifier image registry
  ## @param sysctlImage.repository Kernel settings modifier image repository
  ## @param sysctlImage.tag Kernel settings modifier image tag
  ## @param sysctlImage.digest Kernel settings modifier image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
  ## @param sysctlImage.pullPolicy Kernel settings modifier image pull policy
  ## @param sysctlImage.pullSecrets Kernel settings modifier image pull secrets
  ##
  registry: docker.io
  repository: bitnami/bitnami-shell
  tag: 11-debian-11-r87
  digest: ""
  pullPolicy: IfNotPresent
  pullSecrets: []
  resources:
    ## Example:
    ## limits:
    ##    cpu: 100m
    ##    memory: 128Mi
    limits: {}
    ## Examples:
    ## requests:
    ##    cpu: 100m
    ##    memory: 128Mi
    requests: {}

kibana:
  elasticsearch:
    hosts:
      - '{{ include "elasticsearch.service.name" . }}'
    port: '{{ include "elasticsearch.service.ports.restAPI" . }}'
